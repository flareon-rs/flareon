use std::any::Any;
use std::panic::PanicHookInfo;
use std::sync::Arc;

use rinja::Template;
use tracing::error;

use crate::config::ProjectConfig;
use crate::error::backtrace::{Backtrace, __cot_create_backtrace};
use crate::error::{Error, ErrorRepr};
use crate::router::Router;
use crate::{Result, StatusCode};

/// Added as a Response extension to trigger displaying the error page.
///
/// If the global request handler finds this in a response generated by a router
/// or view, it intercepts the response and displays the error page instead.
#[derive(Debug, Clone)]
pub(crate) enum ErrorPageTrigger {
    NotFound { message: Option<String> },
}

#[derive(Debug)]
pub(super) struct Diagnostics {
    project_config: ProjectConfig,
    router: Arc<Router>,
    request_parts: Option<http::request::Parts>,
}

impl Diagnostics {
    #[must_use]
    pub(super) fn new(
        project_config: ProjectConfig,
        router: Arc<Router>,
        request_parts: Option<http::request::Parts>,
    ) -> Self {
        Self {
            project_config,
            router,
            request_parts,
        }
    }
}

#[derive(Debug, Template)]
#[template(path = "error.html")]
struct ErrorPageTemplate {
    kind: Kind,
    error_message: Option<String>,
    panic_string: Option<String>,
    panic_location: Option<String>,
    backtrace: Option<Backtrace>,
    error_data: Vec<ErrorData>,
    route_data: Vec<RouteData>,
    request_data: Option<RequestData>,
    project_config: String,
}

#[derive(Debug, Default, Clone)]
struct ErrorPageTemplateBuilder {
    kind: Kind,
    error_message: Option<String>,
    panic_string: Option<String>,
    panic_location: Option<String>,
    backtrace: Option<Backtrace>,
    error_data: Vec<ErrorData>,
    route_data: Vec<RouteData>,
    request_data: Option<RequestData>,
    project_config: String,
}

impl ErrorPageTemplateBuilder {
    #[must_use]
    fn not_found(message: Option<String>) -> Self {
        Self {
            kind: Kind::NotFound,
            error_message: message,
            ..Default::default()
        }
    }

    #[must_use]
    fn error(error: Error) -> Self {
        let mut error_data = Vec::new();
        Self::build_error_data(&mut error_data, &error);

        Self {
            kind: Kind::Error,
            error_data,
            backtrace: Some(error.backtrace().clone()),
            ..Default::default()
        }
    }

    #[must_use]
    fn panic(panic_payload: Box<dyn Any + Send>) -> Self {
        Self {
            kind: Kind::Panic,
            panic_string: Self::get_panic_string(panic_payload),
            panic_location: PANIC_LOCATION.take(),
            backtrace: PANIC_BACKTRACE.take(),
            ..Default::default()
        }
    }

    fn diagnostics(&mut self, diagnostics: Diagnostics) -> &mut Self {
        self.project_config = format!("{:#?}", diagnostics.project_config);
        self.route_data.clear();
        Self::build_route_data(&mut self.route_data, &diagnostics.router, "", "");
        self.request_data = diagnostics
            .request_parts
            .as_ref()
            .map(Self::build_request_data);
        self
    }

    fn build_route_data(
        route_data: &mut Vec<RouteData>,
        router: &Router,
        url_prefix: &str,
        index_prefix: &str,
    ) {
        for (index, route) in router.routes().iter().enumerate() {
            route_data.push(RouteData {
                index: format!("{index_prefix}{index}"),
                path: format!("{url_prefix}{}", route.url()),
                kind: match route.kind() {
                    crate::router::RouteKind::Router => if route_data.is_empty() {
                        "Root Router"
                    } else {
                        "Router"
                    }
                    .to_owned(),
                    crate::router::RouteKind::Handler => "View".to_owned(),
                },
                name: route.name().unwrap_or_default().to_owned(),
            });

            if let Some(inner_router) = route.router() {
                Self::build_route_data(
                    route_data,
                    inner_router,
                    &format!("{}{}", url_prefix, route.url()),
                    &format!("{index_prefix}{index}."),
                );
            }
        }
    }

    fn build_error_data(vec: &mut Vec<ErrorData>, error: &(dyn std::error::Error + 'static)) {
        let data = ErrorData {
            description: error.to_string(),
            debug_str: format!("{error:#?}"),
            is_cot_error: error.is::<Error>(),
        };
        vec.push(data);

        if let Some(source) = error.source() {
            Self::build_error_data(vec, source);
        }
    }

    #[must_use]
    fn build_request_data(parts: &http::request::Parts) -> RequestData {
        RequestData {
            method: parts.method.to_string(),
            url: parts.uri.to_string(),
            protocol_version: format!("{:?}", parts.version),
            headers: parts
                .headers
                .iter()
                .map(|(name, value)| {
                    (
                        name.as_str().to_owned(),
                        String::from_utf8_lossy(value.as_ref()).into_owned(),
                    )
                })
                .collect(),
        }
    }

    #[must_use]
    fn get_panic_string(panic_payload: Box<dyn Any + Send>) -> Option<String> {
        if let Some(&panic_string) = panic_payload.downcast_ref::<&str>() {
            Some(panic_string.to_owned())
        } else {
            panic_payload.downcast_ref::<String>().cloned()
        }
    }

    fn render(&self) -> Result<String> {
        Ok(ErrorPageTemplate {
            kind: self.kind,
            error_message: self.error_message.clone(),
            panic_string: self.panic_string.clone(),
            panic_location: self.panic_location.clone(),
            backtrace: self.backtrace.clone(),
            error_data: self.error_data.clone(),
            route_data: self.route_data.clone(),
            request_data: self.request_data.clone(),
            project_config: self.project_config.clone(),
        }
        .render()
        .map_err(ErrorRepr::from)?)
    }
}

#[derive(Debug, Copy, Clone, PartialEq, Eq, Default)]
enum Kind {
    NotFound,
    #[default]
    Error,
    Panic,
}

#[derive(Debug, Clone)]
struct ErrorData {
    description: String,
    debug_str: String,
    is_cot_error: bool,
}

#[derive(Debug, Clone, PartialEq, Eq)]
struct RouteData {
    index: String,
    path: String,
    kind: String,
    name: String,
}

#[derive(Debug, Clone)]
struct RequestData {
    method: String,
    url: String,
    protocol_version: String,
    headers: Vec<(String, String)>,
}

#[must_use]
pub(super) fn handle_not_found(
    message: Option<String>,
    diagnostics: Diagnostics,
) -> axum::response::Response {
    build_response(
        build_not_found_response(message, diagnostics),
        StatusCode::NOT_FOUND,
    )
}

#[must_use]
pub(super) fn handle_response_panic(
    panic_payload: Box<dyn Any + Send>,
    diagnostics: Diagnostics,
) -> axum::response::Response {
    build_response(
        build_panic_response(panic_payload, diagnostics),
        StatusCode::INTERNAL_SERVER_ERROR,
    )
}

#[must_use]
pub(super) fn handle_response_error(
    error: Error,
    diagnostics: Diagnostics,
) -> axum::response::Response {
    build_response(
        build_error_response(error, diagnostics),
        StatusCode::INTERNAL_SERVER_ERROR,
    )
}

#[must_use]
fn build_response(
    response_string: Result<String>,
    status_code: StatusCode,
) -> axum::response::Response {
    match response_string {
        Ok(error_str) => axum::response::Response::builder()
            .status(status_code)
            .body(axum::body::Body::new(error_str))
            .unwrap_or_else(|_| build_cot_failure_page()),
        Err(error) => {
            error!("Failed to render error page: {}", error);
            build_cot_failure_page()
        }
    }
}

fn build_not_found_response(message: Option<String>, diagnostics: Diagnostics) -> Result<String> {
    ErrorPageTemplateBuilder::not_found(message)
        .diagnostics(diagnostics)
        .render()
}

fn build_panic_response(
    panic_payload: Box<dyn Any + Send>,
    diagnostics: Diagnostics,
) -> Result<String> {
    ErrorPageTemplateBuilder::panic(panic_payload)
        .diagnostics(diagnostics)
        .render()
}

fn build_error_response(error: Error, diagnostics: Diagnostics) -> Result<String> {
    ErrorPageTemplateBuilder::error(error)
        .diagnostics(diagnostics)
        .render()
}

const DEFAULT_SERVER_ERROR_PAGE: &[u8] = include_bytes!("../templates/500.html");
const DEFAULT_NOT_FOUND_PAGE: &[u8] = include_bytes!("../templates/404.html");
const FAILURE_PAGE: &[u8] = include_bytes!("../templates/fail.html");

/// A last-resort Internal Server Error page.
///
/// Returned when a custom error page fails to render.
pub(super) fn build_cot_server_error_page() -> axum::response::Response {
    axum::response::Response::builder()
        .status(StatusCode::INTERNAL_SERVER_ERROR)
        .body(axum::body::Body::from(DEFAULT_SERVER_ERROR_PAGE))
        .expect("Building the Cot server error page should never fail")
}

/// A last-resort Not Found page.
///
/// Returned when a custom error page fails to render.
pub(super) fn build_cot_not_found_page() -> axum::response::Response {
    axum::response::Response::builder()
        .status(StatusCode::NOT_FOUND)
        .body(axum::body::Body::from(DEFAULT_NOT_FOUND_PAGE))
        .expect("Building the Cot not found page should never fail")
}

/// A last-resort error page.
///
/// This page is displayed when an error occurs that prevents Cot from rendering
/// a proper error page. This page is very simple and should only be displayed
/// in the event of a catastrophic failure, likely caused by a bug in Cot
/// itself.
#[must_use]
fn build_cot_failure_page() -> axum::response::Response {
    axum::response::Response::builder()
        .status(StatusCode::INTERNAL_SERVER_ERROR)
        .body(axum::body::Body::from(FAILURE_PAGE))
        .expect("Building the Cot failure page should never fail")
}

thread_local! {
    static PANIC_LOCATION: std::cell::RefCell<Option<String>> = const { std::cell::RefCell::new(None) };
    static PANIC_BACKTRACE: std::cell::RefCell<Option<Backtrace>> = const { std::cell::RefCell::new(None) };
}

pub(super) fn error_page_panic_hook(info: &PanicHookInfo<'_>) {
    let location = info.location().map(|location| format!("{location}"));
    PANIC_LOCATION.replace(location);

    PANIC_BACKTRACE.replace(Some(__cot_create_backtrace()));
}

#[cfg(test)]
mod tests {
    use std::sync::Arc;

    use super::*;
    use crate::router::{Route, Router};
    use crate::test::TestRequestBuilder;

    fn create_diagnostics() -> Diagnostics {
        let project_config = ProjectConfig::default();
        let router = Arc::new(Router::with_urls(vec![]));
        let request = TestRequestBuilder::get("/").build();
        let (parts, _body) = request.into_parts();

        Diagnostics::new(project_config, router, Some(parts))
    }

    #[test]
    fn test_handle_not_found() {
        let diagnostics = create_diagnostics();

        let response = handle_not_found(None, diagnostics);

        assert_eq!(response.status(), StatusCode::NOT_FOUND);
    }

    #[test]
    fn test_handle_response_panic() {
        let diagnostics = create_diagnostics();
        let panic_payload = Box::new("panic occurred");

        let response = handle_response_panic(panic_payload, diagnostics);

        assert_eq!(response.status(), StatusCode::INTERNAL_SERVER_ERROR);
    }

    #[test]
    fn test_handle_response_error() {
        let diagnostics = create_diagnostics();
        let error = Error::new(ErrorRepr::NoViewToReverse {
            view_name: "error occurred".to_string(),
        });

        let response = handle_response_error(error, diagnostics);

        assert_eq!(response.status(), StatusCode::INTERNAL_SERVER_ERROR);
    }

    #[test]
    fn build_route_data() {
        let mut route_data = Vec::new();
        let sub_sub_router = Router::with_urls(vec![]);
        let sub_router = Router::with_urls(vec![Route::with_router("/bar", sub_sub_router)]);
        let router = Router::with_urls(vec![Route::with_router("/foo", sub_router)]);

        ErrorPageTemplateBuilder::build_route_data(&mut route_data, &router, "", "");

        assert_eq!(
            route_data,
            vec![
                RouteData {
                    index: "0".to_string(),
                    path: "/foo".to_string(),
                    kind: "Root Router".to_string(),
                    name: String::new()
                },
                RouteData {
                    index: "0.0".to_string(),
                    path: "/foo/bar".to_string(),
                    kind: "Router".to_string(),
                    name: String::new()
                }
            ]
        );
    }

    #[test]
    fn test_build_cot_failure_page() {
        let response = build_cot_failure_page();
        assert_eq!(response.status(), StatusCode::INTERNAL_SERVER_ERROR);
    }
}
